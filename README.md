# P.O.C.: Serverless, Quarkus Lambda Http, Spring, AWS SQS

Proof of concept aiming the integration of a *full fledged* Quarkus/Spring API with multiple endpoints running
from a single Lambda function, accessing AWS Simple Queue Service via SDK 2.15 without making use
of the Quarkus SQS extension. The concept provides both JVM and native versions using the *native container build*,
so no local GraalVM installation is required.

## Introduction

The single most troublesome characteristic of cloud functions is the **cold start**, which adds uncomfortable
amounts of delay to the completion of a function's execution, after it being dormant or not used for longer periods
of time (usually around 5 minutes, depending mainly on resources' availability on AWS and amount of allocated
memory). This feature becomes even worse when writing cloud functions in *compiled languages*, such as
Java or C#, making a single cold start worth over 10 or even 15 seconds of delay, rendering such solutions **impractical
for latency sensitive applications**, such as APIs serving end users via mobile or web clients.

Another cumbersome aspect of cloud function programming, is the fact that in the standard approach of
writing APIs with them, each endpoint's verb ends up getting assigned to a single function, making such architecture
**highly coupled to the infrastucture** and usually **depadronized**.

The architectural attempt presented in this POC aims to approach these two topics by providing the
following solutions:
* **A single cloud function must serve the entire API**. This approach allows the usage of tried
  and tested frameworks, in this case *Spring*, in the form of Quarkus Spring Extensions, permiting 
  as such a standardized development pattern. This general concept would allow the API to be easily
  migrated to any other Spring compatible infra-structure, such as ECS or Elastic Beanstalk.
  

* **Usage of lightning fast application initialization solution.** Java/Spring applications were not 
  designed to have a fast startup procedure. Their original idea is to be instantiated once and 
  respond to requests while staying up. The revolutionary [Quarkus](https://quarkus.io/) framework 
  supplies an incredibly fast boot time (usually under 0.5s), providing the startup agility one would
  need to run a Java application on a cloud function, hence completely mitigating the cold start issue.
  

The following instructions should allow the developer to build, execute and deploy a copy of this project locally and
on his AWS Account.

## Contents
* [Stack](#stack)
* [Installation](#installation)
* [Deploy and remove stack](#deploy-and-remove-stack)
* [Testing the endpoints](#testing-the-endpoints)

## Stack
* [Java JDK 1.8](https://www.oracle.com/java/technologies/javase-jdk8-downloads.html) or [11](https://www.oracle.com/java/technologies/javase-jdk11-downloads.html) - Required Java version. **1.8** will work, but **11** is preferred. 
* [Maven 3](https://maven.apache.org/) - Dependency and build management.
* [Lombok Plugin](https://projectlombok.org/) - Make sure your IDE supports **Lombok**.
* [IntelliJ IDEA](https://www.jetbrains.com/) - Or any IDE of your choice.
* [Git](https://git-scm.com/) - Versioning system.
* [NodeJS 12+](https://nodejs.org/en/download/) - Pre-requisite for the *Serverless Framework* and deployment scripts.
* [Serverless Framework](https://www.serverless.com/framework/docs/getting-started/) - Infraestrutura como c√≥digo, arquitetura serverless.

## Installation
Make sure you install and confirm the installation of the pre-required technologies if not already 
done *(Java JDK, Maven, IDE's Lombok Plugin, NodeJS 12+, Git)*. Details on how this should be done 
will not be covered on this documentation and should be looked for individually at each vendor's resource.
The following steps should be executed from the command terminal of your operational system:

1. Make a local copy of this repository.
    ```
    git clone https://github.com/RogerVFbr/serverless-quarkus-spring-lambda-sqs.git
    ```

2. Install the *Serverless Framework* if not already done.
    ```
    npm install -g serverless
    ```

3. From the project root, install the Node dependencies.
    ```
    npm install
    ```
4. Open the project in your preferred IDE and use your **pom.xml** to update the project's dependencies.

## Service credentials
It's strongly advisable, and a good practice to provide a new IAM user for each newly created service
for security purposes. Whether you create a new IAM user or reuse one, you will need it
to have the proper *policies* attached so you can actually deploy the service via infrastucture-as-code
(*Serverless Framework*). Make sure the IAM user you choose for this project has at least full 
access to Lambda, SQS, Cloudformation and Cloudwatch resources. For production, further permissions
limiting may be required.

This service's deployment scripts depend entirely on the profile generated by the process below,
so they **won't work** if you skip this step and use your default credentials. You can also use
your default credentials, just make sure you also register them on the service's profile following the 
steps below.

1. Obtain or generate the AWS IAM credentials to be used on this service and retrieve 
   it's **ACCESS KEY ID** and **SECRET ACCESS KEY**. If you're unsure on how to create an IAM user,
   [follow the AWS documentation here](https://docs.aws.amazon.com/IAM/latest/UserGuide/id_users_create.html).


2. Use provided script to generate a local profile with the acquired credentials by running the 
   command below from the project's root folder. Pay extra attention to the syntax with double 
   dashes and spacing.

    ```
    npm run set-service-credentials -- --key <ACCESS_KEY_ID> --secret <SECRET_ACCESS_KEY>
    ```

3. If needed, double check if a credentials profile named *quarkus_sqs* has been properly created. 
   If you're not sure how to do this, refer to the [AWS documentation](https://docs.aws.amazon.com/cli/latest/userguide/cli-configure-files.html).

## Deploy and remove stack
For the sake of simplicity and cross-platform availability, the command sequences and 
parameterization required to build and deploy this project were encapsulated on *package.json*'s 
scripts section. If you need any further details about how the process is being done, you can refer 
to it.

#### Deploy stack
The deploy command will build and deploy two Lambdas linked to an API Gateway, containing each a 
different version of the API's code. The first one will be deployed as the JVM version, using AWS's 
Java 8 runtime, and the second will provide a native version running on a custom runtime. Each 
version will be built on its proprietary *target* folder (*target* and *target-native*) and will 
also have its own root path, so you can check the different response time characteristics, 
specially the *[cold starts](https://aithority.com/it-and-devops/cloud/5-ways-to-prevent-aws-lambda-cold-starts/)*.
The process will also attempt to set the terminal Java version to 11 before building.

To deploy the service stack, execute from the project's root folder:
```
npm run deploy
```

#### Remove stack
To completely remove the stack from your AWS account, execute from the project's root:
```
npm run remove
```

#### Running locally
To run the API locally, you can execute the provided script from the project's root. The script will
also parse the environment variables located in the **serverless.yml** definition and provide
them at runtime, so you can access your newly created SQS queue. You will have to deploy the
stack before running locally or else it won't be able to access the queue.
```
npm run start-local
```

## Testing the endpoints
After deploying the stack to AWS, the *Serverless Framework* will provide the endpoint base URLs.
Access them with CURL to test the newly deployed API. If running locally, use **http://localhost:8080/**
as base URL.

To POST a new message to SQS, run the following command on the terminal:
```
# JVM ENDPOINT
curl -v -d '{"attributeName1": "attributeValue1"}' -H 'Content-Type: application/json' <REPLACE_BY_THE_BASE_URL>/dev/jvm/sqs

# NATIVE ENDPOINT
curl -v -d '{"attributeName2": "attributeValue2"}' -H 'Content-Type: application/json' <REPLACE_BY_THE_BASE_URL>/dev/native/sqs

# LOCAL
curl -v -d '{"attributeName3": "attributeValue3"}' -H 'Content-Type: application/json' http://localhost:8080/sqs
```

To GET the SQS content, run the following command on the terminal:
```
# JVM ENDPOINT
curl -v -i -X GET <REPLACE_BY_THE_BASE_URL>/dev/jvm/sqs

# NATIVE ENDPOINT
curl -v -i -X GET <REPLACE_BY_THE_BASE_URL>/dev/native/sqs

# LOCAL
curl -v -i -X GET http://localhost:8080/sqs
```

if you need to double check the endpoints' base URLs at AWS, run from the project root:
```
sls info --aws-profile quarkus_sqs
```